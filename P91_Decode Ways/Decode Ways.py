# coding=utf8

__author__ = 'smilezjw'


class Solution:
    def numDecoding(self, s):
        if s == '' or s[0] == '0':
            return 0
        dp = [0 for i in xrange(len(s)+1)]  # 状态转移方程中状态数为len(s)+1
        dp[0] = 1    # dp[i]表示长度为i的数字串可能的解码方案
        dp[1] = 1    # dp[0] = 1 是为了便于计算dp[2]，不用单独拎出来计算
        for i in xrange(2, len(s)+1):
            # 如果长度为i的前两位连续数字范围在10~26并且不包括10和20，那么这两个子串有两种方法解码
            # 单个数字解码就是dp[i-1]
            # 两个数字连在一起解码就是dp[i-2]
            if 10 <= int(s[i-2:i]) <= 26 and s[i-1] != '0':
                dp[i] = dp[i-2] + dp[i-1]
            # 如果两个数字为10或者20，那只能连在一起解码dp[i-2]
            elif int(s[i-2:i]) == 10 or int(s[i-2:i]) == 20:
                dp[i] = dp[i-2]
            # 如果两个数字不在上述范围并且没有出现0（这里肯定能够判断是没有出现0，
            # 因为s[0] == '0'已经排除了，然后每次判断s[i-2:i]中的是s[i-1]!= '0',
            # 那其实是把非10和20中的0都给排除掉了），例如45，那么只能单个数字解码
            elif s[i-2] != '0':
                dp[i] = dp[i-1]
            # 非10和20出现0的情况（如09和50），都不能解码，解码方案返回0
            else:
                return 0
        return dp[-1]

if __name__ == '__main__':
    s = Solution()
    print s.numDecoding('00')
    print s.numDecoding('301')
    print s.numDecoding('1233')
    print s.numDecoding('1234')

#####################################################################################
# 用动态规划求解。需要判断连续两个数字的范围，如果是10~26之间并且不包括10和20，那么
# 可以有两种解码方法；如果是10或者20，那只有一种解码方法；否则不在上述范围内的并且不
# 出现0的情况也只有一种解码方法；如果出现0并且不是10或者20的话，则没有解码方案，返回0。
#